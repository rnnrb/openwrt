--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -1507,6 +1507,14 @@ static unsigned ata_exec_internal_sg(str
 		return AC_ERR_SYSTEM;
 	}
 
+	if (ap->ops->acquire_hw && !ap->ops->acquire_hw(ap, 0, 0)) {
+		spin_unlock_irqrestore(ap->lock, flags);
+		if (!ap->ops->acquire_hw(ap, 1, (2*HZ))) {
+			return AC_ERR_TIMEOUT;
+		}
+		spin_lock_irqsave(ap->lock, flags);
+	}
+
 	/* initialize internal qc */
 	qc = __ata_qc_from_tag(ap, ATA_TAG_INTERNAL);
 
@@ -4705,6 +4713,8 @@ void ata_qc_free(struct ata_queued_cmd *
 	qc->flags = 0;
 	if (ata_tag_valid(qc->tag))
 		qc->tag = ATA_TAG_POISON;
+	if (ap->ops->qc_free)
+		ap->ops->qc_free(qc);
 }
 
 void __ata_qc_complete(struct ata_queued_cmd *qc)
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -894,6 +894,8 @@ struct ata_port_operations {
 	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue)(struct ata_queued_cmd *qc);
 	bool (*qc_fill_rtf)(struct ata_queued_cmd *qc);
+	int (*qc_new)(struct ata_port *ap);
+	void (*qc_free)(struct ata_queued_cmd *qc);
 
 	/*
 	 * Configuration and exception handling
@@ -985,6 +987,9 @@ struct ata_port_operations {
 	void (*phy_reset)(struct ata_port *ap);
 	void (*eng_timeout)(struct ata_port *ap);
 
+	int (*acquire_hw)(struct ata_port *ap, int may_sleep,
+			  int timeout_jiffies);
+
 	/*
 	 * ->inherits must be the last field and all the preceding
 	 * fields must be pointers.
--- a/drivers/ata/libata-scsi.c
+++ b/drivers/ata/libata-scsi.c
@@ -645,6 +645,9 @@ static struct ata_queued_cmd *ata_scsi_q
 	if (unlikely(ap->pflags & ATA_PFLAG_FROZEN))
 		goto fail;
 
+	if (ap->ops->qc_new && ap->ops->qc_new(ap))
+		goto fail;
+
 	if (ap->flags & ATA_FLAG_SAS_HOST) {
 		/*
 		 * SAS hosts may queue > ATA_MAX_QUEUE commands so use
